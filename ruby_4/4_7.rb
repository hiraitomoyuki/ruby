# 配列

# 添え字を使うと、添え字の位置と取得する長さを指定することができる。
配列[位置, 取得する長さ]

# 2つめの要素から3つ分の要素を取り出す
a = [1, 2, 3, 4, 5]
a[1, 3] # => [2, 3, 4]

# values_atメソッドを使うと、取得したい要素の添え字を複数指定できる
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) # => [1, 3, 5]

# [配列の長さ-1]を指定すると、最後の要素を取得できる
a = [1, 2, 3]
# 最後の要素を取得する
a[a.size - 1] # => 3

# Rubyでは添え字に負の値が使える。-1は最後の要素、-2は最後から2番目の要素というような指定も可
a = [1, 2, 3]
# 最後の要素を取得する
a[-1] # => 3
# 最後から2番目の要素を取得する
a[-2] # => 2
# 最後から2番目の要素から2つの要素を取得する
a[-2, 2] # => [2, 3]

# 配列にはlastというメソッドがあり、これを呼ぶと配列の最後の要素を取得することができる。引数に0以上の数値を渡すと、最後のn個の要素を取得できる。
a = [1, 2, 3]
a.last    # => 3
a.last(2) # => [2, 3]

# lastの反対のfirstもある。先頭の要素を取得するメソッド
a = [1, 2, 3]
a.first    # => 1
a.first(2) # => [1, 2]

# さまざまな要素の変更方法
# 値を変更する場合も負の添え字が使える。ただし、正の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる。
a = [1, 2, 3]
a[-3] = 10 # => [-10, 2, 3]
# 指定可能な負の値よりも小さくなるとエラーが発生する
a[-4] = 0 # => IndexError: index -4 too small for array; minimum: -3

# 開始位置と長さを指定して要素を書き換えることもできる
a = [1, 2, 3, 4, 5]
# 2つめから3要素分を100で置き換える
a[1, 3] = 100
a # => [1, 100, 5]

# <<だけでなく、pushメソッドを使っても要素を追加できる。pushメソッドの場合は複数の値を追加することができる。
a = []
a.push(1)    # => [1]
a.push(2, 3) # => [1, 2, 3]

# 指定した値に一致する要素を削除したい場合はdeleteメソッドを使う
a = [1, 2, 3, 1, 2, 3]
# 値が2である要素を削除する(削除した値が戻り値になる)
a.delete(2) # => 2
a           # => [1, 3, 1, 3]

# 存在しない値を指定するとnilが返る
a.delete(5) # => nil
a           # => [1, 3, 1, 3]


# 配列の連結
# 2つの配列を連結したい場合はconcatメソッドか、+演算子を使う。違いは元の配列を変更するかどうか(破壊的かどうか)
# concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更される。
a = [1]
b = [2, 3]
a.concat(b) # => [1, 2, 3]
# aは変更される(破壊的)
a # => [1, 2, 3]
# bは変更されない
b # => [2, 3]

# +を使うと元の配列を変更せず、新しい配列を作成する。
a = [1]
b = [2, 3]
a + b # => [1, 2, 3]
# aもbも変更されない(非破壊的)
a # => [1]
b # => [2, 3]

# どちらも「配列を連結する」という用途は同じだが、破壊的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合がある。
# なので、「どうしても」という場合以外は+演算子を使うことをおすすめ


# 配列の和集合、差集合、積集合
# Rubyの配列は|,-,&を使って、和集合、差集合、積集合を求めるできる
# |は和集合を求める演算子。2つの配列の要素をすべて集め、重複しないように返します
a = [1, 2, 3]
b = [3, 4, 5]
a | b # => [1, 2, 3, 4, 5]
a = [1, 2, 3]
b = [3, 4, 5]
a - b # => [1, 2]
a = [1, 2, 3]
b = [3, 4, 5]
a & b # => [3]

# |,-,&のいずれも、元の配列は変更しません(非破壊的)
# なお、Rubyには配列よりも効率的に集合を扱えるSetクラスもある。本格的な集合演算をする場合は、配列よりもSetクラスを使う方がよい。
require 'set'

a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
a | b # => #<Set: {1, 2, 3, 4, 5}>
a - b # => #<Set: {1, 2}>
a & b # => #<Set: {3}>
