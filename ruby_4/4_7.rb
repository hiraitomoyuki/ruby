# 配列

# 添え字を使うと、添え字の位置と取得する長さを指定することができる。
配列[位置, 取得する長さ]

# 2つめの要素から3つ分の要素を取り出す
a = [1, 2, 3, 4, 5]
a[1, 3] # => [2, 3, 4]

# values_atメソッドを使うと、取得したい要素の添え字を複数指定できる
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4) # => [1, 3, 5]

# [配列の長さ-1]を指定すると、最後の要素を取得できる
a = [1, 2, 3]
# 最後の要素を取得する
a[a.size - 1] # => 3

# Rubyでは添え字に負の値が使える。-1は最後の要素、-2は最後から2番目の要素というような指定も可
a = [1, 2, 3]
# 最後の要素を取得する
a[-1] # => 3
# 最後から2番目の要素を取得する
a[-2] # => 2
# 最後から2番目の要素から2つの要素を取得する
a[-2, 2] # => [2, 3]

# 配列にはlastというメソッドがあり、これを呼ぶと配列の最後の要素を取得することができる。引数に0以上の数値を渡すと、最後のn個の要素を取得できる。
a = [1, 2, 3]
a.last    # => 3
a.last(2) # => [2, 3]

# lastの反対のfirstもある。先頭の要素を取得するメソッド
a = [1, 2, 3]
a.first    # => 1
a.first(2) # => [1, 2]

# さまざまな要素の変更方法
# 値を変更する場合も負の添え字が使える。ただし、正の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる。
a = [1, 2, 3]
a[-3] = 10 # => [-10, 2, 3]
# 指定可能な負の値よりも小さくなるとエラーが発生する
a[-4] = 0 # => IndexError: index -4 too small for array; minimum: -3

# 開始位置と長さを指定して要素を書き換えることもできる
a = [1, 2, 3, 4, 5]
# 2つめから3要素分を100で置き換える
a[1, 3] = 100
a # => [1, 100, 5]

# <<だけでなく、pushメソッドを使っても要素を追加できる。pushメソッドの場合は複数の値を追加することができる。
a = []
a.push(1)    # => [1]
a.push(2, 3) # => [1, 2, 3]

# 指定した値に一致する要素を削除したい場合はdeleteメソッドを使う
a = [1, 2, 3, 1, 2, 3]
# 値が2である要素を削除する(削除した値が戻り値になる)
a.delete(2) # => 2
a           # => [1, 3, 1, 3]

# 存在しない値を指定するとnilが返る
a.delete(5) # => nil
a           # => [1, 3, 1, 3]


# 配列の連結
# 2つの配列を連結したい場合はconcatメソッドか、+演算子を使う。違いは元の配列を変更するかどうか(破壊的かどうか)
# concatメソッドを使って配列を連結すると、元の配列(メソッドを呼び出した側の配列)が変更される。
a = [1]
b = [2, 3]
a.concat(b) # => [1, 2, 3]
# aは変更される(破壊的)
a # => [1, 2, 3]
# bは変更されない
b # => [2, 3]

# +を使うと元の配列を変更せず、新しい配列を作成する。
a = [1]
b = [2, 3]
a + b # => [1, 2, 3]
# aもbも変更されない(非破壊的)
a # => [1]
b # => [2, 3]

# どちらも「配列を連結する」という用途は同じだが、破壊的な変更は大きなプログラムやフレームワークの中では思いがけないところに悪影響を与えてしまう場合がある。
# なので、「どうしても」という場合以外は+演算子を使うことをおすすめ


# 配列の和集合、差集合、積集合
# Rubyの配列は|,-,&を使って、和集合、差集合、積集合を求めるできる
# |は和集合を求める演算子。2つの配列の要素をすべて集め、重複しないように返します
a = [1, 2, 3]
b = [3, 4, 5]
a | b # => [1, 2, 3, 4, 5]
a = [1, 2, 3]
b = [3, 4, 5]
a - b # => [1, 2]
a = [1, 2, 3]
b = [3, 4, 5]
a & b # => [3]

# |,-,&のいずれも、元の配列は変更しません(非破壊的)
# なお、Rubyには配列よりも効率的に集合を扱えるSetクラスもある。本格的な集合演算をする場合は、配列よりもSetクラスを使う方がよい。
require 'set'

a = Set.new([1, 2, 3])
b = Set.new([3, 4, 5])
a | b # => #<Set: {1, 2, 3, 4, 5}>
a - b # => #<Set: {1, 2}>
a & b # => #<Set: {3}>


# 多重代入で残りの前要素を配列として受け取る
# 多重代入では左辺の変数よりも右辺の個数が多い場合ははみ出した値が切り捨てられる
e, f = 100, 200, 300
e # => 100
f # => 200
# しかし、左辺の変数に*をつけると、残りの全要素を配列として受け取ることができる
e, *f = 100, 200, 300
e # => 100
f # => [200, 300]

# 1つの配列を複数の引数として展開する
# pushメソッドの説明ではa.push(2, 3)のようにして複数の要素を一度に追加できると説明したが
a = []
a.push(1)    # => [1]
# 2と3を一度に追加する
a.push(2, 3) # =>[1, 2, 3]

# もし、この2,3が配列になっていた場合はどうなるでしょう
a = []
b = [2, 3]
a.push(1) # => [1]
# 配列をそのまま追加する (a.push[2, 3]と同じ)
a.push(b) # => [1, [2, 3]]
# 2つの要素ではなく、1つの要素として要素が追加されてしまった。メソッドの引数に配列を渡すとき、「1つの配列」ではなく、配列を展開して「複数の引数」として渡したい場合は、配列の前に*を置きます(splat展開)。
a = []
b = [2, 3]
a.push(1)  # => [1]
# 配列を*付きで追加する (a.push(2, 3)と同じ)
a.push(*b) # => [1, 2, 3]

# 要素に入っているとピンと来ないかもしれないが、イメージ的には
a.push(*b)
↓
a.push(*[2, 3])
↓
a.push(2, 3)

# 配列を引数に渡す場合は、「1つの配列」として渡したいのか、「複数の引数」として渡したいのか検討し、後者の場合は*を使って配列を展開できる


# メソッドの可変長引数
# 配列のpushメソッドのように、個数に制限のない引数のことを可変長引数と言う。自分で定義するメソッドで可変長引数を使いたい場合は、引数名の手前に*をつける
def メソッド名(引数1, 引数2, *可変長引数)
  # メソッドの処理
end
# 可変長引数は配列として受け取るができる。たとえば次は引数として渡された人名の全員にあいさつをするメソッド(コードで使われるjoinメソッドは、引数の区切り文字を使って配列を1つの文字列にするメソッド)
def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
greeting('田中さん')                       # => "田中さん、こんにちは！"
greeting('田中さん', '鈴木さん')            # => "田中さんと鈴木さん、こんにちは！"
greeting('田中さん', '鈴木さん', '佐藤さん') # => "田中さんと鈴木さんと佐藤さん、こんにちは！"


# *で配列同士を非破壊的に連結する
# []の中に*付きで別の配列をおくと、その配列が展開されて別々の要素になる。これもsplat展開の一種
a = [1, 2, 3]

# []の中にそのまま配列をおくと、配列の配列になる
[a] # => [[1, 2, 3]]

# *付きで配列をおくと、展開されて別々の要素になる
[*a] # => [1, 2, 3]

# これを利用すると、別の配列を要素の一部とする新しい配列を作ることができる
a = [1, 2, 3]
[-1, 0, *a, 4, 5] # => [-1, 0, 1, 2, 3, 4, 5]
# *ではなく、以下のように+を使うこともできるが、*を使ったほうが簡潔なコードになる
a = [1, 2, 3]
[-1, 0] + a + [4, 5] # => [-1, 0, 1, 2, 3, 4, 5]
